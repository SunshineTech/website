---
title: Flutter内幕
---

本文档描述了使Flutter的API成为可能的Flutter工具包的内部工作原理。因为Flutter小部件是使用积极的组合构建的，所以使用Flutter构建的用户界面具有大量小部件。为了支持这种工作负载，Flutter使用次线性算法来布局和构建小部件以及使树手术高效且具有许多恒定因子优化的数据结构。通过一些额外的细节，这种设计还使开发人员可以使用回调来轻松创建无限滚动列表，这些回调可以构建用户可见的小部件。

## 积极的可组合性

Flutter最独特的一个方面是其 _积极的可组合性_。小部件是通过组合其他小部件构建的，这些小部件本身是由逐步更基本的小部件构建的。例如，`Padding`是一个小部件而不是其他小部件的属性。因此，使用Flutter构建的用户界面由许多小部件组成。

在`renderObjectWidgets`中构建递归的小部件从下到下，它是在底层 _渲染_ 树中创建节点的小部件。渲染树是存储用户界面几何图形的数据结构，该几何图形在 _布局_ 期间计算，并在 _绘制_ 和 _命中测试 _期间使用。大多数flutter开发人员不直接编写渲染对象，而是使用小部件操作渲染树。

为了在小部件层支持积极的可组合性，Flutter在小部件和渲染树层使用了许多有效的算法和优化，这些将在以下小节中介绍。

### 次线性布局

使用大量小部件和渲染对象，良好性能的关键是高效的算法。最重要的是 _布局_ 的性能，布局是确定渲染对象的几何图形（例如，大小和位置）的算法。其他一些工具包使用O(N²)或更差的（例如，某些约束域中的定点迭代）布局算法。Flutter的目标是初始布局的线性性能，以及随后更新现有布局的常见情况下的 _次线性布局性能_。通常，在布局中花费的时间应该比渲染对象的数量缩放得慢。

Flutter每帧执行一个布局，布局算法一次完成。_约束_ 由调用每个子对象的布局方法的父对象向下传递给树。子对象递归地执行自己的布局，然后通过从其布局方法返回将 _几何图形_ 向上返回到树中。重要的是，一旦渲染对象从其布局方法返回，该渲染对象将不再被访问<sup><a href="#a1">1</a></sup>，直到下一帧的布局。这种方法将可能单独的度量和布局传递组合成单个传递，因此，每个渲染对象在布局期间访问 _最多两次_<sup><a href="#a2">2</a></sup>：一次向下到树，一次向上到树。

Flutter有这个通用协议的几个专业。最常见的专业是1RenderBox1，它以二维笛卡尔坐标运算。在框布局中，约束是最小和最大宽度以及最小和最大高度。在布局期间，子项通过选择这些边界内的大小来确定其几何图形。子项从布局返回后，父项决定子项在父项坐标系<sup><a href="#a3">3</a></sup>中的位置。请注意，子项的布局不能取决于子项的位置，因为子项的位置直到子项从布局返回后才确定。因此，父项可以自由地重新定位子项而无需重新计算子项的布局。

更一般地说，在布局期间，从父节点流向子节点的 _唯一_ 信息是约束，从子节点流向父节点的 _唯一_ 信息是几何图形。这些不变量可以减少布局期间所需的工作量：

* 如果子节点没有将自己的布局标记为脏，只要父节点给子节点的约束与子节点在前一个布局中收到的约束相同，则子节点可以立即从布局返回，切断遍历。

* 每当父节点调用子节点的布局方法时，父节点指示它是否使用从子节点返回的大小信息。如果经常发生，父节点不使用大小信息，那么如果子节点选择新大小，则父节点不需要重新计算其布局，因为父节点保证新大小将符合现有约束。

* _严格约束_ 是指那些恰好一个有效几何图形可以满足的约束。例如，如果最小和最大宽度彼此相等并且最小和最大高度彼此相等，则满足这些约束的唯一大小是具有该宽度和高度的大小。如果父节点提供严格约束，则父节点无需在子节点重新计算其布局时重新计算布局，即使父节点在其布局中使用子节点的大小，因为子节点在没有父节点的新约束的情况下也无法更改大小。

* 渲染对象可以声明它仅使用父节点提供的约束来确定其几何图形。这样的声明通知框架该渲染对象的父节点在子节点重新计算其布局时不需要重新计算布局，_即使约束不严格_，_即使父节点的布局取决于子节点的大小_，因为子节点在没有来自父节点的新约束的情况下无法更改大小。

作为这些优化的结果，当渲染对象树包含脏节点时，在布局期间仅访问那些节点以及它们周围的子树的有限部分。

### 次线性小部件构建

与布局算法类似，Flutter的小部件构建算法是次线性的。构建之后，小部件由元素树保存，_元素树_ 保留用户界面的逻辑结构。元素树是必要的，因为小部件本身是 _不可变的_，这意味着（除其他外），它们不能记住它们与其他小部件的父或子关系。元素树还包含与有状态小部件关联的 _状态_ 对象。

响应于用户输入（或其他刺激），元素可能变脏，例如，如果开发人员在关联的状态对象上调用`setState()`。框架保留一个脏元素列表，并在 _构建_ 阶段直接跳转到它们，跳过干净的元素。在构建阶段，信息在元素树中向下 _单向_ 流动，这意味着在构建阶段期间每个元素最多被访问一次。清洁后，元素不会再次变脏，因为通过感应，它的所有祖先元素也都是干净的<sup><a href="#a4">4</a></sup>。

因为小部件是 _不可变的_，所以如果元素没有将自己标记为脏，则元素可以立即从构建返回，如果父级使用相同的小部件重建元素，则会切断遍历。此外，元素只需要比较两个小部件引用的对象标识，以确定新小部件与旧小部件相同。开发人员利用此优化来实现 _重投影_ 模式，其中小部件包括存储为其构建中的成员变量的预构建子小部件。

在构建期间，Flutter还避免使用`InheritedWidget`遍历父链。如果小部件通常遍历其父链，例如确定当前的主题颜色，则构建阶段将在树的深度变为O(N²)，由于积极组合，这可能非常大。为了避免这些父遍历，框架通过在每个元素上维护一个`InheritedWidget`的哈希表来向下推送元素树中的信息。通常，许多元素将引用相同的哈希表，该哈希表仅在引入新`InheritedWidget`的元素上进行更改。

### 线性调节

与流行的看法相反，Flutter没有采用树差分算法。相反，框架通过使用O(N)算法独立地检查每个元素的子列表来决定是否重用元素。子列表调节算法针对以下情况进行了优化：

* 旧子列表为空。
* 两个列表相同。
* 在列表中恰好一个位置插入或删除一个或多个小部件。
* 如果每个列表包含具有相同键的小部件，则两个小部件匹配。

一般方法是通过比较每个小部件的运行时类型和键来匹配两个子列表的开头和结尾，可能在包含所有不匹配子节点的每个列表的中间找到非空范围。然后，框架将旧子列表范围中的子项放入基于其键的哈希表中。接下来，框架遍历新子列表中的范围，并按键查询哈希表以进行匹配。不匹配的子项被丢弃并从头开始重建，而匹配的子项则用其新小部件重建。

### 树手术

重用元素对性能很重要，因为元素拥有两个关键数据：有状态小部件的状态和底层的渲染对象。当框架能够重用元素时，保留用户界面的逻辑部分的状态，并且可以重用先前计算的布局信息，通常避免整个子树遍历。实际上，重用元素非常有价值，以至于Flutter支持保留状态和布局信息的 _非本地_ 树突变。

开发人员可以通过将`GlobalKey`与其中一个小部件相关联来执行非本地树突变。每个全局键在整个应用程序中都是唯一的，并使用特定于线程的哈希表进行注册。在构建阶段，开发人员可以使用全局键将小部件移动到元素树中的任意位置。框架将检查哈希表并将现有元素从其先前位置重定父级到新位置，从而保留整个子树，而不是在该位置构建新元素。

重定父级的子树中的渲染对象能够保留其布局信息，因为布局约束是渲染树中从父级流向子级的唯一信息。新的父级被标记为布局脏，因为其子列表已更改，但如果新的父级传递给子级其从其旧父级接收的相同布局限制，则子级可以立即从布局返回，从而切断遍历。

开发人员广泛使用全局键和非本地树突变来实现英雄过渡和导航等效果。

### 恒定因子优化

除了这些算法优化之外，实现积极的可组合性还依赖于几个重要的恒定因子优化。这些优化在上面讨论的主要算法的叶子中是最重要的。

* **子模型不可知论者。** 与大多数使用子列表的工具包不同，Flutter的渲染树不会提交给特定的子模型。例如，`RenderBox`类具有抽象的`visitChildren()`方法，而不是具体的 _firstChild_ 和 _nextSibling_ 接口。许多子类仅支持单个子项，直接作为成员变量而不是子项列表。例如，`RenderPadding`仅支持单个子节点，因此，具有更简单的执行时间更短的布局方法。

* **可视化渲染树，逻辑小部件树。** 在Flutter中，渲染树在与设备无关的可视坐标系中运行，这意味着即使当前读取方向是从右到左，x坐标中的较小值也始终向左。小部件树通常在逻辑坐标中操作，意味着具有开始和结束值，其视觉解释取决于读取方向。从逻辑坐标到可视坐标的转换是在小部件树和渲染树之间的切换中完成的。 这种方法更有效，因为渲染树中的布局和绘制计算比小部件到渲染树的切换更频繁，并且可以避免重复的坐标转换。

* **由专门的渲染对象处理的文本。** 绝大多数渲染对象都不了解文本的复杂性。相反，文本由专门的渲染树中叶子的渲染对象`RenderParagraph`处理。开发人员不是子类化文本感知渲染对象，而是使用组合将文本合并到用户界面中。这种模式意味着`RenderParagraph`可以避免重新计算其文本布局，只要其父级提供相同的布局约束，即使在树木手术期间也是如此。

* **可观察对象。** Flutter使用模型观察和反应范式。显然，反应范式占主导地位，但Flutter对某些叶子数据结构使用可观察的模型对象。例如，Animation在其值发生变化时通知观察者列表。Flutter将这些可观察对象从小部件树移交给渲染树，渲染树直接观察它们并且在它们改变时仅使管道的适当阶段无效。例如，对 _Animation_ 的更改可能仅触发绘制阶段，而不是构建和绘制阶段。

综合并总结了由积极组合创建的大型树，这些优化对性能有重大影响。

## 无限滚动

无限滚动列表对于工具包来说是非常困难的。Flutter支持基于 _构建器_ 模式的简单接口的无限滚动列表，其中`ListView`使用回调按需构建小部件，因为它们在滚动期间对用户可见。支持此功能需要 _视口感知布局_ 并 _按需构建小部件_。

### 视口感知布局

像Flutter中的大多数东西一样，可滚动的小部件是使用组合构建的。可滚动小部件的外部是一个视口（Viewport），它是一个“内部较大”的框，这意味着它的子视图可以超出视口的边界，并可以滚动到视图中。但是，视口不具有`RenderBox`子元素，而具有`RenderSliver`子元素，称为 _sliver_，具有视口感知布局协议。

sliver布局协议与框布局协议的结构相匹配，因为父级将约束传递给子级并接收返回中的几何图形。但是，约束和几何数据在两个协议之间不同。在sliver协议中，向子级提供有关视口的信息，包括剩余的可见空间量。它们返回的几何数据启用了各种滚动链接效果，包括可折叠标题和视差。

不同的sliver以不同的方式填充视口中可用的空间。例如，产生线性子列表的sliver按顺序排列每个子项，直到sliver用完子项或用完空间。类似地，产生二维子网格的sliver仅填充其可见的网格部分。因为他们知道有多少空间是可见的，即使他们有可能产生无限数量的子项，只产生有限数量的子项。

可以组合Sliver来创建定制的可滚动布局和效果。例如，单个视口可以具有可折叠标题，后跟线性列表，然后是网格。所有三个sliver都将通过sliver布局协议进行合作，以仅生成通过视口实际可见的子项，无论这些子项是否属于标题，列表或网格。

### 按需构建小部件

如果Flutter有一个严格的 _构建 - 然后 - 布局 - 然后 - 绘制_ 管道，前面的内容将不足以实现无限滚动列表，因为通过视口可以看到多少空间的信息仅在布局阶段可用。如果没有额外的机器，布局阶段就太晚了，无法构建填充空间所需的小部件。Flutter通过交错管道的构建和布局阶段来解决这个问题。在布局阶段的任何时候，_只要这些小部件是当前执行布局的渲染对象的后代_，框架就可以开始按需构建新的小部件。

只有在构建和布局算法中对信息传播进行严格控制，才能实现交错构建和布局。具体而言，在构建阶段，信息只能沿树传播。当渲染对象执行布局时，布局遍历没有访问该渲染对象下面的子树，这意味着通过在该子树中构建而生成的写入不能使到目前为止已进入布局计算的任何信息无效。类似地，一旦布局从渲染对象返回，在此布局期间将永远不再访问该渲染对象，这意味着后续布局计算生成的任何写入都不会使用于构建渲染对象的子树的信息无效。

此外，线性调节和树手术对于在滚动期间有效更新元素以及在元素在视口边缘滚动进出视图时修改渲染树至关重要。

## API人体工程学

快速只有在框架可以实际有效使用时才有意义。为了引导Flutter的API设计更具可用性，Flutter已经在开发人员的广泛用户体验研究中反复测试过。这些研究有时会确认已有的设计决策，有时可以帮助指导功能的优先级，有时会改变API设计的方向。例如，Flutter的API记录很多；用户体验研究证实了此类文档的价值，但也强调了专门针对示例代码和说明性图表的需求。

本节讨论Flutter API设计中为帮助可用性而做出的一些决策。

### 匹配开发人员思维模式的专门API

Flutter的`Widget`，`Element`和`RenderObject`树中节点的基类未定义子模型。这允许每个节点专用于适用于该节点的子模型。

大多数`Widget`对象都有一个子`Widget`，因此只公开一个`child`参数。一些小部件支持任意数量的子节点，并公开接受列表的`children`参数。有些小部件根本没有任何子节点，并且没有内存，也没有任何参数。同样，`RenderObjects`公开特定于其子模型的API。`RenderImage`是叶节点，没有子节点的概念。`RenderPadding`只接受一个子节点，因此它具有单子节点的单个指针的存储。`RenderFlex`接受任意数量的子节点并将其作为链表进行管理。

在一些罕见的情况下，使用更复杂的子模型。`RenderTable`渲染对象的构造函数接受一个子节点数组的数组，该类公开控制行数和列数的getter和setter，并且有一些特定的方法可以用x，y坐标替换单个子节点，以添加一行，以提供一个新的子节点数组的数组，并用一个数组和一个列数替换整个子列表。在实现中，对象不像大多数渲染对象那样使用链表，而是使用可索引数组。

`Chip`小部件和`InputDecoration`对象具有与相关控件上存在的插槽匹配的字段。如果一个通用的子模型将强制语义分层在子列表之上，例如，将第一个子项定义为前缀值，将第二个子项定义为后缀，则专用子模型允许使用专用的命名属性。

这种灵活性允许这些树中的每个节点以其最常用的角色进行操作。很少想要在表格中插入一个单元格，导致所有其他单元格换行；同样，很少想要通过索引而不是通过引用从flex行中删除子项。

`RenderParagraph`对象是最极端的情况：它有一个完全不同类型（`TextSpan`）的子节点。在`RenderParagraph`边界处，`RenderObject`树转换为`TextSpan`树。

专门用于满足开发人员期望的API的整体方法不仅适用于子模型。

一些相当琐碎的小部件专门存在，以便开发人员在寻找问题的解决方案时找到它们。一旦知道如何使用`Expanded`小部件和零大小的`SizedBox`子项，就可以轻松地为行或列添加空格，但发现该模式是不必要的，因为搜索`space`会发现直接使用`Expanded`和`SizedBox`达到效果的`Spacer`小部件。

类似地，通过根本不在构建中包括小部件子树，可以容易地隐藏小部件子树。但是，开发人员通常希望有一个小部件来执行此操作，因此存在`Visibility`小部件以将此模式包装在一个简单的可重用小部件中。

### 显式参数

UI框架往往具有许多属性，因此开发人员很少能够记住每个类的每个构造函数参数的语义含义。由于Flutter使用反应范式，因此Flutter中的构建方法通常会对构造函数进行多次调用。 通过利用Dart对命名参数的支持，Flutter的API能够使这些构建方法保持清晰易懂。

此模式扩展到具有多个参数的任何方法，特别是扩展到任何布尔参数，因此方法调用中隔离的`true`或`false`文字始终是自我记录的。此外，为避免通常由API中的双重否定引起的混淆，布尔参数和属性始终以正形式命名（例如，`enabled: true`而不是`disabled: false`）。

### 在陷阱上铺砌

在Flutter框架中的许多地方使用的技术是定义API，使得错误条件不存在。这样可以避免考虑整个错误类。

例如，插值函数允许插值的一端或两端为空，而不是将其定义为错误情况：两个空值之间的插值始终为空，并且从空值或空值插值等效于对给定类型插值为零模拟。这意味着不小心将空传递给插值函数的开发人员不会遇到错误情况，而是会获得合理的结果。

`Flex`布局算法中有一个更微妙的例子。这种布局的概念是赋予flex渲染对象的空间在其子节点之间划分，因此flex的大小应该是整个可用空间。在原始设计中，提供无限空间会失败：这意味着flex应该是无限大小的，无用的布局配置。相反，API已经过调整，以便在为flex渲染对象分配无限空间时，渲染对象会调整其大小以适合所需的子级大小，从而减少可能的错误情况数。

该方法还用于避免允许创建不一致数据的构造函数。例如，`PointerDownEvent`构造函数不允许将`PointerEvent`的`down`属性设置为`false`（这种情况会自相矛盾）；相反，构造函数没有`down`字段的参数，并始终将其设置为`true`。

通常，该方法是为输入域中的所有值定义有效解释。最简单的例子是`Color`构造函数。不是接受四个整数（一个用于红色，一个用于绿色，一个用于蓝色，一个用于alpha，每个都可能超出范围），默认构造函数接受单个整数值，并定义每个位的含义（ 例如，最下面的八位定义红色分量），因此任何输入值都是有效的颜色值。

一个更精细的例子是`paintImage()`函数。此函数接受11个参数，其中一些具有相当宽的输入域，但它们经过精心设计，大部分彼此正交，因此很少有无效组合。

### 积极报告错误案例

并非所有错误条件都可以设计出来。对于那些剩下的，在调试版本中，Flutter通常会尝试很早地捕获错误并立即报告它们。断言被广泛使用。构造函数参数详细检查完整性。监视生命周期，当检测到不一致时，它们会立即引发异常抛出。

在某些情况下，这是极端的：例如，在运行单元测试时，无论测试正在做什么，每个积极布局的`RenderBox`子类都会检查其内部大小调整方法是否满足内部大小调整契约。这有助于捕获可能无法执行的API中的错误。

抛出异常时，它们包含尽可能多的信息。Flutter的一些错误消息会主动探测相关的堆栈跟踪，以确定实际错误的最可能位置。其他则遍历相关的树来确定不良数据的来源。最常见的错误包括详细说明，包括在某些情况下用于避免错误的示例代码或指向其他文档的链接。

### 反应范式

可变的基于树的API受二元访问模式的影响：创建树的原始状态通常使用与后续更新完全不同的操作集。Flutter的渲染层使用这种范式，因为它是维护持久树的有效方法，这是高效布局和绘画的关键。但是，这意味着与渲染层的直接交互充其量是尴尬的，而最坏的情况则容易出错。

Flutter的小部件层引入了一个使用反应范式来操纵底层渲染树的组合机制。此API通过将树创建和树变异步骤组合到单个树描述（构建）步骤中抽象出树操作，其中，在每次更改系统状态之后，开发人员描述用户界面的新配置，并且框架计算反映这种新配置所必需的一系列树突变。

### 插值

由于Flutter的框架鼓励开发人员描述与当前应用程序状态匹配的接口配置，因此存在一种在这些配置之间隐式动画的机制。

例如，假设在状态S<sub>1</sub>中，界面由圆圈组成，但在状态S<sub>2</sub>中，它由正方形组成。如果没有动画机制，状态更改将会有一个不和谐的界面更改。隐式动画允许圆在几帧上平滑正方形化。

可以隐式动画的每个功能都有一个有状态小部件，用于记录输入的当前值，并在输入值更改时开始动画序列，在指定的持续时间内从当前值转换为新值。

This is implemented using `lerp` (linear interpolation) functions using
这是使用`lerp`（线性插值）函数使用不可变对象实现的。每个状态（在这种情况下为圆形和正方形）表示为不可变对象，配置有适当的设置（颜色，笔触宽度等）并知道如何绘制自身。当在动画期间绘制中间步骤时，将开始和结束值传递给适当的`lerp`函数以及表示动画点的 _t_ 值，其中0.0表示`start`，1.0表示`end`，函数返回表示中间阶段的第三个不可变对象。

对于圆到正方形的转换，`lerp`函数将返回一个表示“圆角正方形”的对象，其半径描述为从t值导出的分数，使用颜色的`lerp`函数插值颜色，以及使用双精度的`lerp`函数插值笔划宽度。该对象实现与圆形和正方形相同的界面，然后可以在请求时绘制自己。

该技术允许状态机制，状态到配置的映射，动画机制，插值机制以及与如何绘制每个帧相关的特定逻辑以完全彼此分离。

这种方法广泛适用。在flutter中，基本类型（如`Color`和`Shape`）可以插值，但更复杂的类型（如`Decoration`、`TextStyle`或`Theme`）也可以插值。这些通常由本身可以插值的组件构成，并且插值更复杂的对象通常就像递归插值描述复杂对象的所有值一样简单。

一些可插值对象由类层次结构定义。例如，形状由`ShapeBorder`接口表示，并且存在各种形状，包括`BeveledRectangleBorder`、`BoxBorder`、`CircleBorder`、`RoundedRectangleBorder`和`StadiumBorder`。单个`lerp`函数不能具有所有可能类型的先验知识，因此接口定义了`lerpFrom`和`lerpTo`方法，静态`lerp`方法遵循这些方法。当被告知从形状A插入到形状B时，首先询问B是否可以`lerpFrom` A，然后，如果不能，则询问A是否可以`lerpTo` B。（如果两者都不可能，则该函数从`t`小于0.5的值返回A ，否则返回B。）

这允许类层次结构被任意扩展，后来的添加能够在先前已知的值和它们自身之间进行插值。

在某些情况下，插值本身不能由任何可用类描述，并且定义私有类来描述中间阶段。例如，在`CircleBorder`和`RoundedRectangleBorder`之间进行插值时就是这种情况。

这种机制还有一个额外的优点：它可以处理从中间阶段到新值的插值。例如，在圆形到方形转换的中途，形状可能再次改变，导致动画需要插入到三角形。只要三角形类可以`lerpFrom`圆角方形中间类，就可以无缝地执行转换。

## 结论

Flutter的口号“一切都是小部件”，围绕着构建用户界面，通过组合小部件来构建，小部件又逐步由更基本的小部件组成。这种积极组合的结果是大量的小部件需要精心设计的算法和数据结构才能有效地处理。通过一些额外的设计，这些数据结构还使开发人员可以轻松创建在可见时按需构建小部件的无限滚动列表。

---
**脚注：**

<sup><a name="a1">1</a></sup> 至少对于布局来说。可以重新审视绘制，必要时构建可访问性树，以及必要时进行命中测试。

<sup><a name="a2">2</a></sup> 当然，现实有点复杂。一些布局涉及内在维度或基线测量，其涉及相关子树的额外遍历（积极缓存用于减轻在最坏情况下二次性能的可能性）。然而，这些案例非常罕见。特别是，收缩包装的常见情况不需要内在维度。

<sup><a name="a3">3</a></sup> 从技术上讲，子项的位置不是其RenderBox几何图形的一部分，因此在布局过程中无需实际计算。许多渲染对象隐含地将它们的单个子节点相对于它们自己的原点定位在0,0，这根本不需要计算或存储。一些渲染对象避免计算他们的子节点的位置直到最后可能的时刻（例如，在绘制阶段期间），以避免如果他们随后没有被绘制而完全计算。

<sup><a name="a4">4</a></sup>  这条规则有一个例外。正如[按需构建小部件](#building-widgets-on-demand)部分所述，由于布局约束的更改，某些小部件可能重构。如果小部件在同一帧中因无关原因标记为脏，以及它也受布局约束更改的影响，则它将更新两次。此冗余构建仅限于小部件本身，不会影响其后代。

<sup><a name="a5">5</a></sup> 键是可选的与小部件相关联的不透明对象，其相等运算符用于影响协调算法。

<sup><a name="a6">6</a></sup>  对于可访问性，并且小部件在构建和在屏幕上显示之间为应用程序提供额外的毫秒数时，视口会在可见小部件之前和之后为几百个像素创建（但不绘制）小部件。

<sup><a name="a7">7</a></sup>  这种方法最初受到Facebook的React库的欢迎。

<sup><a name="a8">8</a></sup>  在实践中，允许 _t_ 值扩展到0.0-1.0范围之外，对于某些曲线也是如此。例如，“弹性”曲线短暂地过冲以表示弹跳效果。插值逻辑通常可以在适当的情况下通过开始或结束进行外推。对于某些类型，例如，在插入颜色时，_t_ 值有效地被钳制到0.0-1.0范围内。
